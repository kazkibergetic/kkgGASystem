---
title: "kkgGASystem"
author: "Oleg Rybkin"
date: "Tuesday, January 13, 2015"
output: html_document
---


###Genetic Algorithms
Genetic Algorithms (GA) belong to the larger class of Evolutionary Algorithms, which use techniques inspired by natural evolution to provide with a close to the best solution to optimization problem.
The structure of an evolution program [1]

```
procedureEvolutionProgram
begin
        t <− 0
        initializeP(t)
        evaluateP(t)
        while (nottermination−condition) do
        begin
                t <− t + 1
                selectP(t) from P(t−1)
                alterP (t)
                evaluateP(t)
        end
end
```
* Initial population
* Selection and genetic operators
    * crossover
    * mutation
* Fitness evaluation
* Termination criterion
   
    
GA has been successfully applied to a large number of problems and real-world applications. The advantage of using GA that it requires less domain knowledge of the problem in order to find close to the best solution.
GA has many application, for example:

* Timetabling problems;
* Travelling salesman problem and its applications;
* Vehicle routing problems;
* Bioinformatics;
* Scheduling applications;
* Learning robot behaviour.

Start file:

>>> evolver/Start.java



###Chromosome Representation
A chromosome representation for the solution space is really important in order to apply GA to a specific problem. So it is one of the critical aspects to the success of the GA.

The GA chromosome representation was chosen in the way to be expressive and powerful enough to represent a solution. 
The chromosome represents a list of natural numbers:

>>> chromosome/IntegerBasedChromosome.java

###Fitness Evaluation
One of the most important concepts of GA is a fitness function. The fitness function determines how well the program is able to solve a problem and provides the information about program efficiency.

Finding "correct" fitness function is very important in order to obtain a reasonable result.

The weighted-sum approach can be viewed as an extension of method used in multi-objective optimization in GA. It assigns weights to each objective function and combines the weighted objectives into a single objective function.

>>> fitness/singleObjective/Simple.java

The Pareto ranking algorithm is incorporated into a genetic algorithm by replacing the chromosome fitnesses with Pareto ranks.[3]

Unlike the weighted-sum approach the Pareto is ranking not trying to combine different objectives but rather trying to analyse different objectives individually. 

>>> fitness/multiObjective/ParetoRanking.java

###Fitness Evaluation based on Rough Sets

####Bireducts

>>> problems/RoughSets/bireduct/Problem.java

Bireducts

* not just a subset of attributes, that describes decisions
* but, also, a subset of objects, for which this subset of
attributes is valid

Let A = (U, A ∪ d) be a decision system. A pair (B,X), where
B ⊆ A and X ⊆ U, is called a decision bireduct, if and only if B
discerns all pairs i, j ∈ X where d(i) != d(j), and the following
properties hold:

* 1 There is no C that is a proper subset of B such that C discerns all pairs i, j ∈ X where d(i) != d(j);
* 2 There is no Y that is a proper subset of X such that B discerns all pairs i, j ∈ Y where d(i) != d(j).

```
Data:
1. decision table A=(U, a(1), ..., a(n) ∪ d)
2. permutation τ (1,..., n+m ) generated by GA, where n=|A| and m=|U|
Result: bireduct (B,X) generated based on permutation τ , where B ⊆ A, X ⊆ U
Method:
B = A, X = ∅
(b(1), ..., b(n+m)) = τ(1, ..., n + m)
for i=1 to n+m do
        if b(i) ≤ n then
                if B \ {a(b(i))} =>(X) d then
                         B = B \ {a(b(i))}
                end
        else
                if B =>(X∪{b(i) −n}) d then
                        X = X ∪{b(i)− n}
                end
        end
end
return (B, X)
```
where the functional dependency denoted as B =>(U) d

B =>(U) d iff (∀a ∈ B )(∀x , y ∈ U )[a(x ) = a(y ) implies d (x ) = d (y )].

